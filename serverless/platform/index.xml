<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Taction's Blog – platform</title><link>https://taction.top/serverless/platform/</link><description>Recent content in platform on Taction's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 04 Nov 2021 15:36:50 +0800</lastBuildDate><atom:link href="https://taction.top/serverless/platform/index.xml" rel="self" type="application/rss+xml"/><item><title>Serverless: Debug Knative</title><link>https://taction.top/serverless/platform/debug-knative/</link><pubDate>Thu, 04 Nov 2021 15:36:50 +0800</pubDate><guid>https://taction.top/serverless/platform/debug-knative/</guid><description>
&lt;p>TL;DR&lt;/p>
&lt;p>本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。&lt;/p>
&lt;h3 id="目标">目标&lt;/h3>
&lt;p>由于knative组件运行在k8s中，当发生错误的时候，在对代码不是特别熟悉的情况下，单步调试程序能够观察程序运行的函数，以及运行过程中的上下文，对排查问题非常方便。实际knative程序允许你在k8s外运行服务组件，通过环境变量或者命令行参数指定kubeconfig和server参数即可。&lt;/p>
&lt;p>但是本文主要介绍另外一种思路，不是所有程序都能方便的运行在本地的。所以对于运行在k8s中的程序进行调试就是本文的目标。&lt;/p>
&lt;h3 id="步骤">步骤&lt;/h3>
&lt;h4 id="镜像">镜像&lt;/h4>
&lt;blockquote>
&lt;p>knative 镜像制作：https://www.likakuli.com/posts/knative-build/&lt;/p>
&lt;/blockquote>
&lt;p>首先要创建一个镜像，编译的二进制和启动命令都会有所不同。通过查看knative组件&lt;/p>
&lt;p>由于knative使用&lt;a href="https://github.com/google/ko">ko&lt;/a>来进行镜像的制作和推送。我简单的看了一下，发现了解这个可能会给我带来一定的时间成本。所以我直接按照自己最舒服的方式自己写了一下Makefile和Dockerfile。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-makefile" data-lang="makefile">REGCFLAGS &lt;span style="color:#f92672">=&lt;/span> -gcflags &lt;span style="color:#e6db74">&amp;#34;all=-N -l&amp;#34;&lt;/span>
SRC_FOLDER &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>shell ls cmd&lt;span style="color:#66d9ef">)&lt;/span>
&lt;span style="color:#a6e22e">prepare&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> ! -d &lt;span style="color:#e6db74">&amp;#34;./bin/&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> mkdir bin; &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#a6e22e">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
@for dir in &lt;span style="color:#e6db74">${&lt;/span>SRC_FOLDER&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> go build &lt;span style="color:#66d9ef">$(&lt;/span>REGCFLAGS&lt;span style="color:#66d9ef">)&lt;/span> -mod vendor -o bin/$$dir ./cmd/$$dir ; &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#a6e22e">remote&lt;/span>&lt;span style="color:#f92672">:&lt;/span> prepare default
&lt;span style="color:#a6e22e">docker&lt;/span>&lt;span style="color:#f92672">:&lt;/span> remote
@for dir in &lt;span style="color:#e6db74">${&lt;/span>SRC_FOLDER&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> docker build --build-arg BIN&lt;span style="color:#f92672">=&lt;/span>$$dir -t docker4zc/$$dir . ; docker push docker4zc/$$dir ; &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#a6e22e">docker-local&lt;/span>&lt;span style="color:#f92672">:&lt;/span> remote
@for dir in &lt;span style="color:#e6db74">${&lt;/span>SRC_FOLDER&lt;span style="color:#e6db74">}&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> docker build --build-arg BIN&lt;span style="color:#f92672">=&lt;/span>$$dir -t docker4zc/$$dir . ; &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> golang:latest AS golang&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">ENV&lt;/span> GOPROXY&lt;span style="color:#f92672">=&lt;/span>https://goproxy.cn,direct&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> CGO_ENABLED&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> go get -ldflags &lt;span style="color:#e6db74">&amp;#39;-s -w -extldflags -static&amp;#39;&lt;/span> github.com/go-delve/delve/cmd/dlv&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e">#FROM gcr.oneitfarm.com/distroless/static:noroot&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> ubuntu&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">ARG&lt;/span> BIN&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">WORKDIR&lt;/span>&lt;span style="color:#e6db74"> /&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> bin/&lt;span style="color:#e6db74">${&lt;/span>BIN&lt;span style="color:#e6db74">}&lt;/span> /execbin&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> --from&lt;span style="color:#f92672">=&lt;/span>golang /go/bin/dlv /&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">CMD&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;/dlv&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;--listen=:2345&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;--headless=true&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;--api-version=2&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;--accept-multiclient&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;exec&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/execbin&amp;#34;&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先你需要在运行命令的地方登陆自己的dockerhub账号，并且将我的dockerhub账号&lt;code>docker4zc&lt;/code>换成你自己的账号，这样你就可以把镜像推送到自己的仓库。然后你在项目主目录下运行&lt;code>make docker&lt;/code>即可。&lt;/p>
&lt;p>然后你需要在这个网址&lt;code>https://github.com/knative/serving/releases/download/v0.26.0/serving-core.yaml&lt;/code>(将v0.26.0替换成你需要的版本)下载安装knative serving的yaml文件，并将你想要调试的组件镜像替换，如果是&lt;code>webhook&lt;/code>组件，那么就是将&lt;code>gcr.io/knative-releases/knative.dev/serving/cmd/webhook@sha256:d512342e1a1ec454ceade96923e21c24ec0f2cb780e86ced8e66eb62033c74b5&lt;/code>格式的镜像替换成&lt;code>docker.io/{your dockerhub account}/webhook:latest&lt;/code>。&lt;/p>
&lt;p>另外由于我将基础镜像由&lt;code>gcr.oneitfarm.com/distroless/static:noroot&lt;/code>替换成了&lt;code>ubuntu&lt;/code>，所以你同时需要将yaml文件中每个deployment下&lt;code>runAsNonRoot: true&lt;/code>去掉。&lt;/p>
&lt;p>接下来你就可以&lt;code>kubectl apply -f serving-core.yaml&lt;/code>将其部署到k8s中。&lt;/p>
&lt;h3 id="端口转发">端口转发&lt;/h3>
&lt;h4 id="转发一个本地端口到-pod-端口">转发一个本地端口到 Pod 端口&lt;/h4>
&lt;p>以下命令将activator的2345端口转发到本地12345端口&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl port-forward -n knative-serving webhook-7b9b84596d-245rh 12345:2345
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这相当于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubectl port-forward -n knative-serving pods/webhook-7b9b84596d-245rh 12345:2345
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubectl port-forward -n knative-serving deployment/webhook 12345:2345
&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考&lt;a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/port-forward-access-application-cluster/#%E8%BD%AC%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E5%88%B0-pod-%E7%AB%AF%E5%8F%A3">使用端口转发来访问集群中的应用&lt;/a>&lt;/p>
&lt;p>如果是在minikube中运行，那么你就是在minikube所在机器运行以上命令。并通过机器ip+12345端口进行连接。如果是在k8s中运行，那么你可以在本地将kubectl设置对应的kubeconfig后，通过127.0.0.1+12345端口进行连接。&lt;/p>
&lt;h4 id="goland-ide远程调试">Goland IDE远程调试&lt;/h4>
&lt;p>VS code和goland都具有此功能，这里以goland为例。在创建时选择go remote类型，设置对应的host和port即可：&lt;/p>
&lt;p>&lt;img src="https://taction.top/images/goremotedebug.png" alt="image-20211107153446536">&lt;/p>
&lt;p>其他参考：&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/149938368">在Kubernetes中远程调试Go服务&lt;/a>&lt;/p></description></item><item><title>Serverless: Knative Use</title><link>https://taction.top/serverless/platform/knative-use/</link><pubDate>Mon, 01 Nov 2021 13:41:20 +0800</pubDate><guid>https://taction.top/serverless/platform/knative-use/</guid><description>
&lt;p>本文档主要介绍跟随&lt;a href="https://knative.dev/docs/getting-started/">官网入门教程&lt;/a>和&lt;a href="https://github.com/csantanapr/knative-minikube">minikube&lt;/a>案例运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下适配。本篇基本未涉及原理性介绍。&lt;/p>
&lt;p>首先确认安装&lt;a href="https://kind.sigs.k8s.io/docs/user/quick-start">kind&lt;/a>或者&lt;a href="https://minikube.sigs.k8s.io/docs/start/">minikube&lt;/a>、&lt;a href="https://kubernetes.io/docs/tasks/tools/">kubectl&lt;/a>、&lt;a href="https://knative.dev/docs/getting-started/#install-the-knative-cli">kn&lt;/a>这些必要的软件。如果你跟随本教程，那么你只需要确认安装minikube和kubectl即可。&lt;/p>
&lt;h3 id="启动minikube">启动minikube&lt;/h3>
&lt;p>当minikube镜像拉取过慢的时候可以参考&lt;a href="https://www.cxyzjd.com/article/TinyJian/109699420">配置代理&lt;/a>。或者通过以下命令来运行minikube&lt;code>minikube start --image-mirror-country='cn' --image-repository='registry.cn-hangzhou.aliyuncs.com/google_containers'&lt;/code>但是这样是不够的。还是无法解决minikube拉取knative镜像问题。你会发现pod的状态被卡在&lt;code>ImagePullBackOff&lt;/code>状态中。&lt;/p>
&lt;p>作为一个成熟的程序员，命令行代理你肯定已经非常熟悉了。这里主要说明一下启动minikube设置的docker-env是配置在拉取镜像中通过此代理拉取。这里要注意第一要把本地代理client监听0.0.0.0，如果为了安全你可以通过网络安全组来限制只能自己的ip访问这个端口。第二将以下命令行中{your ip}替换成你主机的实际公网ip。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># 命令行代理&lt;/span>
export http_proxy&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:1080&amp;#34;&lt;/span>
export https_proxy&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:1080&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># 启动minikube&lt;/span>
minikube start &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>--image-mirror-country cn &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>--image-repository&lt;span style="color:#f92672">=&lt;/span>registry.cn-hangzhou.aliyuncs.com/google_containers &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>--docker-env http_proxy&lt;span style="color:#f92672">=&lt;/span>http://&lt;span style="color:#f92672">{&lt;/span>your ip&lt;span style="color:#f92672">}&lt;/span>:1080 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>--docker-env https_proxy&lt;span style="color:#f92672">=&lt;/span>http://&lt;span style="color:#f92672">{&lt;/span>your ip&lt;span style="color:#f92672">}&lt;/span>:1080 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>--docker-env no_proxy&lt;span style="color:#f92672">=&lt;/span>localhost,127.0.0.1,10.96.0.0/12,192.168.99.0/24,192.168.39.0/24
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装knative">安装knative&lt;/h3>
&lt;p>选择要安装的版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">export KNATIVE_VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;0.26.0&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>定义knative自己的各项CustomResourceDefinition（CRD）来扩展k8s API。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f https://github.com/knative/serving/releases/download/v$KNATIVE_VERSION/serving-crds.yaml
kubectl wait --for&lt;span style="color:#f92672">=&lt;/span>condition&lt;span style="color:#f92672">=&lt;/span>Established --all crd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建knative-serving namespace并且安装各项knative组件。在这个yaml里定义了namespace、k8s权限及绑定、一些crd资源以及knative组件deployment。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f https://github.com/knative/serving/releases/download/v$KNATIVE_VERSION/serving-core.yaml
kubectl wait pod --timeout&lt;span style="color:#f92672">=&lt;/span>-1s --for&lt;span style="color:#f92672">=&lt;/span>condition&lt;span style="color:#f92672">=&lt;/span>Ready -l &lt;span style="color:#e6db74">&amp;#39;!job-name&amp;#39;&lt;/span> -n knative-serving &amp;gt; /dev/null
&lt;/code>&lt;/pre>&lt;/div>&lt;p>选择你要安装的Net Kourier版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">export KNATIVE_NET_KOURIER_VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;0.26.0&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;code>kourier-system&lt;/code> namespace下安装kourier&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f https://github.com/knative/net-kourier/releases/download/v$KNATIVE_NET_KOURIER_VERSION/kourier.yaml
kubectl wait pod --timeout&lt;span style="color:#f92672">=&lt;/span>-1s --for&lt;span style="color:#f92672">=&lt;/span>condition&lt;span style="color:#f92672">=&lt;/span>Ready -l &lt;span style="color:#e6db74">&amp;#39;!job-name&amp;#39;&lt;/span> -n kourier-system
kubectl wait pod --timeout&lt;span style="color:#f92672">=&lt;/span>-1s --for&lt;span style="color:#f92672">=&lt;/span>condition&lt;span style="color:#f92672">=&lt;/span>Ready -l &lt;span style="color:#e6db74">&amp;#39;!job-name&amp;#39;&lt;/span> -n knative-serving
&lt;/code>&lt;/pre>&lt;/div>&lt;p>你也可以通过以下命令来查看创建了哪些pod以及它们的状态&lt;code>watch kubectl get pods -n knative-serving&lt;/code>。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ kubectl get pods -n knative-serving
NAME READY STATUS RESTARTS AGE
activator-7b9b84596d-245rh 1/1 Running 0 23m
autoscaler-65cbff8f7d-bg4w7 1/1 Running 0 23m
controller-7d8f4849d8-dnmsq 1/1 Running 0 23m
domain-mapping-676785d476-jx6dd 1/1 Running 0 23m
domainmapping-webhook-7949444d7d-z8plp 1/1 Running 0 23m
webhook-58975ff8d-kqtrx 1/1 Running 0 23m
&lt;/code>&lt;/pre>&lt;p>当所有的都处于running状态的时候，即启动完成，否则你可以根据对应的status判断是否出现了问题。&lt;/p>
&lt;p>新开一个命令行终端运行以下命令。您需要这样做才能使用&lt;code>EXTERNAL-IP&lt;/code>for kourier Load Balancer 服务。&lt;/p>
&lt;pre tabindex="0">&lt;code>minikube tunnel
&lt;/code>&lt;/pre>&lt;p>将环境变量设置为&lt;code>EXTERNAL_IP&lt;/code>工作节点的外部 IP 地址，您可能需要多次运行此命令，直到服务就绪。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">EXTERNAL_IP&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl -n kourier-system get service kourier -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{.status.loadBalancer.ingress[0].ip}&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
echo EXTERNAL_IP&lt;span style="color:#f92672">=&lt;/span>$EXTERNAL_IP
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令将环境变量设置&lt;code>KNATIVE_DOMAIN&lt;/code>为 DNS 域&lt;code>nip.io&lt;/code>，并检查dns可以被正常解析。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">KNATIVE_DOMAIN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$EXTERNAL_IP&lt;span style="color:#e6db74">.nip.io&amp;#34;&lt;/span>
echo KNATIVE_DOMAIN&lt;span style="color:#f92672">=&lt;/span>$KNATIVE_DOMAIN
dig $KNATIVE_DOMAIN
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为 Knative 服务配置 DNS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl patch configmap -n knative-serving config-domain -p &lt;span style="color:#e6db74">&amp;#34;{\&amp;#34;data\&amp;#34;: {\&amp;#34;&lt;/span>$KNATIVE_DOMAIN&lt;span style="color:#e6db74">\&amp;#34;: \&amp;#34;\&amp;#34;}}&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置knative使用kourier&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl patch configmap/config-network &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --namespace knative-serving &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --type merge &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --patch &lt;span style="color:#e6db74">&amp;#39;{&amp;#34;data&amp;#34;:{&amp;#34;ingress.class&amp;#34;:&amp;#34;kourier.ingress.networking.knative.dev&amp;#34;}}&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来你就可以进行服务部署了。&lt;/p>
&lt;h3 id="部署服务">部署服务&lt;/h3>
&lt;pre tabindex="0">&lt;code>cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
name: hello
spec:
template:
spec:
containers:
- image: gcr.oneitfarm.com/knative-samples/helloworld-go
ports:
- containerPort: 8080
env:
- name: TARGET
value: &amp;quot;Knative&amp;quot;
EOF
&lt;/code>&lt;/pre>&lt;p>等待服务部署完成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl wait ksvc hello --all --timeout&lt;span style="color:#f92672">=&lt;/span>-1s --for&lt;span style="color:#f92672">=&lt;/span>condition&lt;span style="color:#f92672">=&lt;/span>Ready
&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取服务的访问url&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">SERVICE_URL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl get ksvc hello -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{.status.url}&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
echo $SERVICE_URL
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问服务,这个时候控制台应该会输出&lt;code>Hello Knative&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>$ curl $SERVICE_URL
&lt;/code>&lt;/pre>&lt;p>我定义了一下输出内容，这样可以看到运行的时候的请求延迟。分别对服务进行冷启动请求和热请求测试。&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -w &amp;quot;@curl-format.txt&amp;quot; $SERVICE_URL
&lt;/code>&lt;/pre>&lt;p>运行结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># 冷启动请求&lt;/span>
curl -w &lt;span style="color:#e6db74">&amp;#34;@curl-format.txt&amp;#34;&lt;/span> $SERVICE_URL
Hello Knative!
time_namelookup: 0.001831
time_connect: 0.002052
time_appconnect: 0.000000
time_redirect: 0.000000
time_pretransfer: 0.002110
time_starttransfer: 1.966370
----------
time_total: 1.966427
&lt;span style="color:#75715e"># 热启动请求&lt;/span>
curl -w &lt;span style="color:#e6db74">&amp;#34;@curl-format.txt&amp;#34;&lt;/span> $SERVICE_URL
Hello Knative!
time_namelookup: 0.194799
time_connect: 0.195032
time_appconnect: 0.000000
time_redirect: 0.000000
time_pretransfer: 0.195137
time_starttransfer: 0.196945
----------
time_total: 0.196989
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个过程中我们可以另外开一个命令行，通过watch pods来查看当有请求时容器被启动，当一段时间内没有请求后，容器数量被缩放到0这一现象。&lt;/p>
&lt;p>&lt;img src="https://taction.top/images/knative-scale.png" alt="image-20211101204945605">&lt;/p>
&lt;h4 id="部署新版本及分流">部署新版本及分流&lt;/h4>
&lt;p>默认情况下knative会将所有流量都导入新版本，你可以增加&lt;code>traffic&lt;/code>字段来指定不同版本的流量比例。&lt;/p>
&lt;pre tabindex="0">&lt;code>cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
name: hello
spec:
template:
metadata:
name: hello-knative-v2
spec:
containers:
- image: gcr.oneitfarm.com/knative-samples/helloworld-go
ports:
- containerPort: 8080
env:
- name: TARGET
value: &amp;quot;Knative V2&amp;quot;
traffic:
- latestRevision: true
percent: 50
- revisionName: hello-00001
percent: 50
EOF
&lt;/code>&lt;/pre>&lt;p>配置成功控制台会输出&lt;/p>
&lt;pre tabindex="0">&lt;code>service.serving.knative.dev/hello configured
&lt;/code>&lt;/pre>&lt;p>这个时候我们再请求就会发现流量被路由到了不同的版本，你可以通过以下命令来查看不同的版本。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kn revisions list
&lt;span style="color:#75715e"># or&lt;/span>
kubectl get revisions
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="服务缩放定义">服务缩放定义&lt;/h4>
&lt;p>可以通过annotations中的定义来指定缩放策略。比如以下策略可以定义从1-5的pod缩放。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cat &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF | kubectl apply -f -
&lt;/span>&lt;span style="color:#e6db74">apiVersion: serving.knative.dev/v1
&lt;/span>&lt;span style="color:#e6db74">kind: Service
&lt;/span>&lt;span style="color:#e6db74">metadata:
&lt;/span>&lt;span style="color:#e6db74"> name: hello
&lt;/span>&lt;span style="color:#e6db74">spec:
&lt;/span>&lt;span style="color:#e6db74"> template:
&lt;/span>&lt;span style="color:#e6db74"> metadata:
&lt;/span>&lt;span style="color:#e6db74"> name: hello-knative-v3
&lt;/span>&lt;span style="color:#e6db74"> annotations:
&lt;/span>&lt;span style="color:#e6db74"> # the minimum number of pods to scale down to
&lt;/span>&lt;span style="color:#e6db74"> autoscaling.knative.dev/minScale: &amp;#34;1&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> # the maximum number of pods to scale up to
&lt;/span>&lt;span style="color:#e6db74"> autoscaling.knative.dev/maxScale: &amp;#34;5&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> # Target in-flight-requests per pod.
&lt;/span>&lt;span style="color:#e6db74"> autoscaling.knative.dev/target: &amp;#34;1&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> spec:
&lt;/span>&lt;span style="color:#e6db74"> containers:
&lt;/span>&lt;span style="color:#e6db74"> - image: gcr.oneitfarm.com/knative-samples/helloworld-go
&lt;/span>&lt;span style="color:#e6db74"> ports:
&lt;/span>&lt;span style="color:#e6db74"> - containerPort: 8080
&lt;/span>&lt;span style="color:#e6db74"> env:
&lt;/span>&lt;span style="color:#e6db74"> - name: TARGET
&lt;/span>&lt;span style="color:#e6db74"> value: &amp;#34;Knative V3&amp;#34;
&lt;/span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时用hey压测就会得到以下结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ hey -z 30s -c &lt;span style="color:#ae81ff">50&lt;/span> http://hello.default.10.104.46.103.nip.io
Summary:
Total: 30.0150 secs
Slowest: 2.1715 secs
Fastest: 0.0024 secs
Average: 0.0353 secs
Requests/sec: 1412.4594
Total data: &lt;span style="color:#ae81ff">763110&lt;/span> bytes
Size/request: &lt;span style="color:#ae81ff">18&lt;/span> bytes
Response time histogram:
0.002 &lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> |
0.219 &lt;span style="color:#f92672">[&lt;/span>42314&lt;span style="color:#f92672">]&lt;/span> |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
0.436 &lt;span style="color:#f92672">[&lt;/span>30&lt;span style="color:#f92672">]&lt;/span> |
0.653 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
0.870 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
1.087 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
1.304 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
1.521 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
1.738 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
1.955 &lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> |
2.171 &lt;span style="color:#f92672">[&lt;/span>50&lt;span style="color:#f92672">]&lt;/span> |
Latency distribution:
10% in 0.0151 secs
25% in 0.0204 secs
50% in 0.0285 secs
75% in 0.0399 secs
90% in 0.0546 secs
95% in 0.0671 secs
99% in 0.1100 secs
Details &lt;span style="color:#f92672">(&lt;/span>average, fastest, slowest&lt;span style="color:#f92672">)&lt;/span>:
DNS+dialup: 0.0024 secs, 0.0024 secs, 2.1715 secs
DNS-lookup: 0.0024 secs, 0.0000 secs, 2.0054 secs
req write: 0.0000 secs, 0.0000 secs, 0.0108 secs
resp wait: 0.0329 secs, 0.0023 secs, 0.2963 secs
resp read: 0.0001 secs, 0.0000 secs, 0.0073 secs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个时候我们查看pod状态，就可以看到其中有一个预启动的比其他存活时间更久&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ k get pods
NAME READY STATUS RESTARTS AGE
hello-knative-v3-deployment-fdf969d79-b8zts 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 81s
hello-knative-v3-deployment-fdf969d79-gr9t2 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 3m17s
hello-knative-v3-deployment-fdf969d79-qhd2s 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 81s
hello-knative-v3-deployment-fdf969d79-sfb8g 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 81s
hello-knative-v3-deployment-fdf969d79-sz4hl 2/2 Running &lt;span style="color:#ae81ff">0&lt;/span> 81s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：如果你设置&lt;code>minScale &amp;gt; 0&lt;/code>将导致每个&lt;code>Revision&lt;/code>Pod 始终至少运行指定数量的 Pod，尽管它们没有获得任何流量。在这种情况下，不要忘记清理旧版本。&lt;/p>
&lt;h3 id="后记">后记&lt;/h3>
&lt;p>通过本篇文章，你可以在自己的minikube中运行knative并且观察其对于服务的实际缩放的现象。并且能够看到服务的冷热启动的请求延迟。&lt;/p>
&lt;p>接下来计划陆续会进行远程调试k8s中的knative组件、对knative组件分析、knative与kong结合案例的分析、knative关键源码分析。&lt;/p></description></item></channel></rss>